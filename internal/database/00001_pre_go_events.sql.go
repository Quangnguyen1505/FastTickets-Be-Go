// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: 00001_pre_go_events.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addNewEvent = `-- name: AddNewEvent :one
INSERT INTO pre_go_events (
    event_name,
    event_description,
    event_image_url,
    event_active,
    event_start,
    event_end,
    user_id,
    created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, NOW()
)
RETURNING id, event_name, event_description, event_image_url, event_active, event_start, event_end, user_id, created_at, updated_at
`

type AddNewEventParams struct {
	EventName        string
	EventDescription pgtype.Text
	EventImageUrl    pgtype.Text
	EventActive      pgtype.Bool
	EventStart       pgtype.Timestamp
	EventEnd         pgtype.Timestamp
	UserID           pgtype.UUID
}

// AddNewEvent
func (q *Queries) AddNewEvent(ctx context.Context, arg AddNewEventParams) (PreGoEvent, error) {
	row := q.db.QueryRow(ctx, addNewEvent,
		arg.EventName,
		arg.EventDescription,
		arg.EventImageUrl,
		arg.EventActive,
		arg.EventStart,
		arg.EventEnd,
		arg.UserID,
	)
	var i PreGoEvent
	err := row.Scan(
		&i.ID,
		&i.EventName,
		&i.EventDescription,
		&i.EventImageUrl,
		&i.EventActive,
		&i.EventStart,
		&i.EventEnd,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM pre_go_events WHERE id = $1
`

// DeleteEvent
func (q *Queries) DeleteEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const getAllActiveEventsWithLikes = `-- name: GetAllActiveEventsWithLikes :many
SELECT
    e.id, e.event_name, e.event_description, e.event_image_url, e.event_active, e.event_start, e.event_end, e.user_id, e.created_at, e.updated_at,
    COUNT(l.user_id) AS like_count
FROM pre_go_events e
LEFT JOIN pre_event_like_user l ON e.id = l.event_id
WHERE e.event_active = TRUE
GROUP BY e.id
ORDER BY e.created_at DESC
    LIMIT $1 OFFSET $2
`

type GetAllActiveEventsWithLikesParams struct {
	Limit  int32
	Offset int32
}

type GetAllActiveEventsWithLikesRow struct {
	ID               pgtype.UUID
	EventName        string
	EventDescription pgtype.Text
	EventImageUrl    pgtype.Text
	EventActive      pgtype.Bool
	EventStart       pgtype.Timestamp
	EventEnd         pgtype.Timestamp
	UserID           pgtype.UUID
	CreatedAt        pgtype.Timestamp
	UpdatedAt        pgtype.Timestamp
	LikeCount        int64
}

// GetAllActiveEvents
func (q *Queries) GetAllActiveEventsWithLikes(ctx context.Context, arg GetAllActiveEventsWithLikesParams) ([]GetAllActiveEventsWithLikesRow, error) {
	rows, err := q.db.Query(ctx, getAllActiveEventsWithLikes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllActiveEventsWithLikesRow
	for rows.Next() {
		var i GetAllActiveEventsWithLikesRow
		if err := rows.Scan(
			&i.ID,
			&i.EventName,
			&i.EventDescription,
			&i.EventImageUrl,
			&i.EventActive,
			&i.EventStart,
			&i.EventEnd,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LikeCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventById = `-- name: GetEventById :one
SELECT id, event_name, event_description, event_image_url, event_active, event_start, event_end, user_id, created_at, updated_at FROM pre_go_events WHERE id = $1
`

// GetEventById
func (q *Queries) GetEventById(ctx context.Context, id pgtype.UUID) (PreGoEvent, error) {
	row := q.db.QueryRow(ctx, getEventById, id)
	var i PreGoEvent
	err := row.Scan(
		&i.ID,
		&i.EventName,
		&i.EventDescription,
		&i.EventImageUrl,
		&i.EventActive,
		&i.EventStart,
		&i.EventEnd,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventByName = `-- name: GetEventByName :one
SELECT id, event_name, event_description, event_image_url, event_active, event_start, event_end, user_id, created_at, updated_at FROM pre_go_events WHERE event_name = $1
`

// GetEventByName
func (q *Queries) GetEventByName(ctx context.Context, eventName string) (PreGoEvent, error) {
	row := q.db.QueryRow(ctx, getEventByName, eventName)
	var i PreGoEvent
	err := row.Scan(
		&i.ID,
		&i.EventName,
		&i.EventDescription,
		&i.EventImageUrl,
		&i.EventActive,
		&i.EventStart,
		&i.EventEnd,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEvent = `-- name: UpdateEvent :exec
UPDATE pre_go_events
SET
    event_name = $2,
    event_description = $3,
    event_image_url = $4,
    event_active = $5,
    event_start = $6,
    event_end = $7,
    user_id = $8,
    updated_at = NOW()
WHERE id = $1
`

type UpdateEventParams struct {
	ID               pgtype.UUID
	EventName        string
	EventDescription pgtype.Text
	EventImageUrl    pgtype.Text
	EventActive      pgtype.Bool
	EventStart       pgtype.Timestamp
	EventEnd         pgtype.Timestamp
	UserID           pgtype.UUID
}

// UpdateEvent
func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) error {
	_, err := q.db.Exec(ctx, updateEvent,
		arg.ID,
		arg.EventName,
		arg.EventDescription,
		arg.EventImageUrl,
		arg.EventActive,
		arg.EventStart,
		arg.EventEnd,
		arg.UserID,
	)
	return err
}
